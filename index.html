<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="分布式，架构，C++，Python">
<meta property="og:type" content="website">
<meta property="og:title" content="李生的博客">
<meta property="og:url" content="http://leehao.io/index.html">
<meta property="og:site_name" content="李生的博客">
<meta property="og:description" content="分布式，架构，C++，Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李生的博客">
<meta name="twitter:description" content="分布式，架构，C++，Python">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://leehao.io/"/>





  <title> 李生的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?371df6f233e7e46671c4a763a94f4976";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">李生的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">记录开发的点点滴滴</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://leehao.io/2017/01/24/C-虚函数表剖析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="李生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="李生的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="李生的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/24/C-虚函数表剖析/" itemprop="url">
                  C++虚函数表剖析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-24T15:23:08+08:00">
                2017-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/24/C-虚函数表剖析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/24/C-虚函数表剖析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关键词：虚函数，虚表，虚表指针，动态绑定，多态</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>为了实现C++的多态，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表（下文简称虚表）。本文介绍虚函数表是如何实现动态绑定的。</p>
<h2 id="二、类的虚表"><a href="#二、类的虚表" class="headerlink" title="二、类的虚表"></a>二、类的虚表</h2><p>每个包含了虚函数的类都包含一个虚表。<br>我们知道，当一个类（A）继承另一个类（B）时，类A会继承类B的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。</p>
<p>我们来看以下的代码。类A包含虚函数vfunc1，vfunc2，由于类A包含虚函数，故类A拥有一个虚表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">public:</div><div class="line">    virtual void vfunc1();</div><div class="line">    virtual void vfunc2();</div><div class="line">    void func1();</div><div class="line">    void func2();</div><div class="line">private:</div><div class="line">    int m_data1, m_data2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>类A的虚表如图1所示。<br><img src="http://img.blog.csdn.net/20160528105449641" alt="这里写图片描述"><br>图1：类A的虚表示意图</p>
<p>虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。<br>虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。</p>
<h2 id="三、虚表指针"><a href="#三、虚表指针" class="headerlink" title="三、虚表指针"></a>三、虚表指针</h2><p>虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。<br>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p><img src="http://img.blog.csdn.net/20160528105539173" alt="这里写图片描述"><br>图2：对象与它的虚表</p>
<p>上面指出，一个继承类的基类如果包含虚函数，那个这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表。</p>
<h2 id="四、动态绑定"><a href="#四、动态绑定" class="headerlink" title="四、动态绑定"></a>四、动态绑定</h2><p>说到这里，大家一定会好奇C++是如何利用虚表和虚表指针来实现动态绑定的。我们先看下面的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">public:</div><div class="line">    virtual void vfunc1();</div><div class="line">    virtual void vfunc2();</div><div class="line">    void func1();</div><div class="line">    void func2();</div><div class="line">private:</div><div class="line">    int m_data1, m_data2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class B : public A &#123;</div><div class="line">public:</div><div class="line">    virtual void vfunc1();</div><div class="line">    void func1();</div><div class="line">private:</div><div class="line">    int m_data3;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class C: public B &#123;</div><div class="line">public:</div><div class="line">    virtual void vfunc2();</div><div class="line">    void func2();</div><div class="line">private:</div><div class="line">    int m_data1, m_data4;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>类A是基类，类B继承类A，类C又继承类B。类A，类B，类C，其对象模型如下图3所示。</p>
<p><img src="http://img.blog.csdn.net/20160528104806455" alt="这里写图片描述"><br>图3：类A，类B，类C的对象模型</p>
<p>由于这三个类都有虚函数，故编译器为每个类都创建了一个虚表，即类A的虚表（A vtbl），类B的虚表（B vtbl），类C的虚表（C vtbl）。类A，类B，类C的对象都拥有一个虚表指针，*__vptr，用来指向自己所属类的虚表。<br>类A包括两个虚函数，故A vtbl包含两个指针，分别指向A::vfunc1()和A::vfunc2()。<br>类B继承于类A，故类B可以调用类A的函数，但由于类B重写了B::vfunc1()函数，故B vtbl的两个指针分别指向B::vfunc1()和A::vfunc2()。<br>类C继承于类B，故类C可以调用类B的函数，但由于类C重写了C::vfunc2()函数，故C vtbl的两个指针分别指向B::vfunc1()（指向继承的最近的一个类的函数）和C::vfunc2()。<br>虽然图3看起来有点复杂，但是只要抓住“对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向其继承的最近的一个类的虚函数”这个特点，便可以快速将这几个类的对象模型在自己的脑海中描绘出来。</p>
<p>非虚函数的调用不用经过虚表，故不需要虚表中的指针指向这些函数。</p>
<p>假设我们定义一个类B的对象。由于bObject是类B的一个对象，故bObject包含一个虚表指针，指向类B的虚表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int main() </div><div class="line">&#123;</div><div class="line">    B bObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，我们声明一个类A的指针p来指向对象bObject。虽然p是基类的指针只能指向基类的部分，但是虚表指针亦属于基类部分，所以p可以访问到对象bObject的虚表指针。bObject的虚表指针指向类B的虚表，所以p可以访问到B vtbl。如图3所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main() </div><div class="line">&#123;</div><div class="line">    B bObject;</div><div class="line">    A *p = &amp; bObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我们使用p来调用vfunc1()函数时，会发生什么现象？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main() </div><div class="line">&#123;</div><div class="line">    B bObject;</div><div class="line">    A *p = &amp; bObject;</div><div class="line">    p-&gt;vfunc1();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序在执行p-&gt;vfunc1()时，会发现p是个指针，且调用的函数是虚函数，接下来便会进行以下的步骤。<br>首先，根据虚表指针p-&gt;<strong>vptr来访问对象bObject对应的虚表。虽然指针p是基类A<em>类型，但是</em></strong>vptr也是基类的一部分，所以可以通过p-&gt;__vptr可以访问到对象对应的虚表。<br>然后，在虚表中查找所调用的函数对应的条目。由于虚表在编译阶段就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。对于 p-&gt;vfunc1()的调用，B vtbl的第一项即是vfunc1对应的条目。<br>最后，根据虚表中找到的函数指针，调用函数。从图3可以看到，B vtbl的第一项指向B::vfunc1()，所以 p-&gt;vfunc1()实质会调用B::vfunc1()函数。</p>
<p>如果p指向类A的对象，情况又是怎么样？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main() </div><div class="line">&#123;</div><div class="line">    A aObject;</div><div class="line">    A *p = &amp;aObject;</div><div class="line">    p-&gt;vfunc1();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当aObject在创建时，它的虚表指针<strong>vptr已设置为指向A vtbl，这样p-&gt;</strong>vptr就指向A vtbl。vfunc1在A vtbl对应在条目指向了A::vfunc1()函数，所以 p-&gt;vfunc1()实质会调用A::vfunc1()函数。</p>
<p>可以把以上三个调用函数的步骤用以下表达式来表示：</p>
<p><code>(*(p-&gt;__vptr)[n])(p)</code></p>
<p>可以看到，通过使用这些虚函数表，即使使用的是基类的指针来调用函数，也可以达到正确调用运行中实际对象的虚函数。<br>我们把经过虚表调用虚函数的过程称为动态绑定，其表现出来的现象称为运行时多态。动态绑定区别于传统的函数调用，传统的函数调用我们称之为静态绑定，即函数的调用在编译阶段就可以确定下来了。</p>
<p>那么，什么时候会执行函数的动态绑定？这需要符合以下三个条件。</p>
<ul>
<li>通过指针来调用函数</li>
<li>指针upcast向上转型（继承类向基类的转换称为upcast，关于什么是upcast，可以参考本文的参考资料）</li>
<li>调用的是虚函数</li>
</ul>
<p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>封装，继承，多态是面向对象设计的三个特征，而多态可以说是面向对象设计的关键。C++通过虚函数表，实现了虚函数与对象的动态绑定，从而构建了C++面向对象程序设计的基石。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《C++ Primer》第三版，中文版，潘爱民等译</li>
<li><a href="http://www.learncpp.com/cpp-tutorial/125-the-virtual-table/" target="_blank" rel="external">http://www.learncpp.com/cpp-tutorial/125-the-virtual-table/</a></li>
<li>侯捷《C++最佳编程实践》视频，极客班，2015 </li>
<li>Upcasting and Downcasting, <a href="http://www.bogotobogo.com/cplusplus/upcasting_downcasting.php" target="_blank" rel="external">http://www.bogotobogo.com/cplusplus/upcasting_downcasting.php</a></li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p> <a href="https://github.com/haozlee/vtable/blob/master/main.cpp" target="_blank" rel="external">示例代码</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://leehao.io/2017/01/24/负载均衡（Load-Balancing）学习笔记-一/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="李生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="李生的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="李生的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/24/负载均衡（Load-Balancing）学习笔记-一/" itemprop="url">
                  负载均衡（Load Balancing）学习笔记(一)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-24T15:05:18+08:00">
                2017-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/24/负载均衡（Load-Balancing）学习笔记-一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/24/负载均衡（Load-Balancing）学习笔记-一/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在分布式系统中，负载均衡（Load Balancing）是一种将任务分派到多个服务端进程的方法。例如，将一个HTTP请求派发到实际的Web服务器中执行的过程就涉及负载均衡的实现。一个HTTP请求到达Web服务器，这中间涉及多个过程，也存在多种不同负载均衡的方法。本文讲述负载均衡的基本原理与派发策略，下图1是负载均衡的基本原理图，图1中客户端的请求请求经过达负载均衡器（Load Balancer）的分派，被指定的服务器进程进行处理。<br><img src="http://img.blog.csdn.net/20161227233044748?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图1：负载均衡基本原理</p>
<p>实现负载均衡主要有两个目的。第一个目的是将任务的处理负载均摊到不同的进程，以减少单一进程的负载，以达到处理能力水平扩容的目的。第二个目的则是提高容错能力。我们知道，在线上正式环境中，机器宕机或者进程异常导致服务不可用是常有的现象。在实现负载均衡的系统中，多个服务器进程提供同样的服务，一个进程不可用的情况下，任务会被负载均衡器派发到其他可用的进程，以达到高可用的目的。在多台不同的服务器中部署相同的服务进程，通过负载均衡对外提供服务，这组进程也称为“集群”（cluster）。</p>
<h1 id="负载均衡实现策略"><a href="#负载均衡实现策略" class="headerlink" title="负载均衡实现策略"></a>负载均衡实现策略</h1><p>常见的负载均衡实现策略有以下几种：</p>
<ul>
<li>均匀派发（Even Task Distribution Scheme）</li>
<li>加权派发（Weighted Task Distribution Scheme）</li>
<li>粘滞会话（Sticky Session Scheme）</li>
<li>均匀任务队列派发（Even Size Task Queue Distribution Scheme）</li>
<li>单一队列（Autonomous Queue Scheme）</li>
</ul>
<h1 id="均匀派发（Even-Task-Distribution-Scheme）"><a href="#均匀派发（Even-Task-Distribution-Scheme）" class="headerlink" title="均匀派发（Even Task Distribution Scheme）"></a>均匀派发（Even Task Distribution Scheme）</h1><p>均匀派发是实现负载均衡最简单的策略，均衡派发的意思是指任务将均匀地派发到所有的服务器进程。在实现时，可以使用随机派发或者轮流派发（Round Robin）。</p>
<p><img src="http://img.blog.csdn.net/20161227233209186?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图2：均匀派发策略</p>
<p>均匀派发策略假设集群内所有进程具有相同的处理能力，且任务处理用时相同。但实际上，由于进程部署环境的不同，其处理能力一般不同，任务处理时间也不尽相同。因此均匀派发的策略并不能很好地将任务负载均滩到各个进程中。</p>
<h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><p>我们知道，DNS提供域名解析服务，当我们访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取指向该域名的IP地址，在这过程中，DNS服务器完成了域名到IP地址的映射。由于这一映射可以是一对多的关系，因此DNS服务器可以充当负载均衡器的作用，DNS服务器在派发IP地址时，正是使用轮流派发的方式来实现的。</p>
<h1 id="加权派发（Weighted-Task-Distribution-Scheme）"><a href="#加权派发（Weighted-Task-Distribution-Scheme）" class="headerlink" title="加权派发（Weighted Task Distribution Scheme）"></a>加权派发（Weighted Task Distribution Scheme）</h1><p>加权派发策略在派发任务时，会赋予服务器进程一个权值，即不同的进程会接受不同数量的任务，具体数量为权值确定。</p>
<p><img src="http://img.blog.csdn.net/20161227233337234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图3：加权派发策略<br>﻿<br>例如，三个进程的处理任务的能力比率为3:3:2，那么可以赋予这三个进程3:3:2的权值，即每8个任务中，3个发派给第一个进程，3个发派给第二个进程，2个分派给第三个进程。<br>加权派发策略考虑了进程处理能力的不同，因此更接近实际的应用。可是，加权派发策略也没有考虑任务处理的要求。</p>
<h1 id="粘滞会话（Sticky-Session-Scheme）"><a href="#粘滞会话（Sticky-Session-Scheme）" class="headerlink" title="粘滞会话（Sticky Session Scheme）"></a>粘滞会话（Sticky Session Scheme）</h1><p>前面两种负载均衡策略并没有考虑任务之间的依赖关系，在实际中，后面的任务处理常常会依赖于前面的任务。例如，对于同一个登录的用户的请求，用户购买的请求依赖于用户登录的请求，如果用户的登录信息保存在进程1中，那么，如果购买请求被分派到进程2或者进程3，那么购买请求将不能正确处理。这种请求间的依赖关系也称为粘滞会话（Sticky Session），负载均衡策略需要考虑粘滞会话的情况。</p>
<p><img src="http://img.blog.csdn.net/20161227233408890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图4：粘滞会话策略</p>
<p>粘滞会话的派发策略要求属于同一个会话的任务将会被分派到同一个进程中。虽然这可以正确处理任务，但是却带来任务派发不均匀的问题，因为一些会话可能包含更多的任务，一些会话包含更少的任务。<br>粘滞会话的另一种处理策略是使用数据库或者缓存，将所有会话数据存储到数据库或者缓存中。集群内所有进程都可以通过访问数据库或者缓存来获取会话数据，进程内存都不保存会话数据，这样，负载均衡器便可以使用前面介绍的策略来派发任务。</p>
<h1 id="均匀任务队列派发（Even-Size-Task-Queue-Distribution-Scheme）"><a href="#均匀任务队列派发（Even-Size-Task-Queue-Distribution-Scheme）" class="headerlink" title="均匀任务队列派发（Even Size Task Queue Distribution Scheme）"></a>均匀任务队列派发（Even Size Task Queue Distribution Scheme）</h1><p>均匀任务队列派发策略跟加权派发策略类似，都考虑了进程的处理能力，不过其实现方式不同。在均匀队列派发策略下，负载均衡器为每个进程都创建一个大小相等的任务队列，这些任务队列包含了对应进程需要处理的任务。任务处理快的进程，其队列也会减少得快，这样负载均衡器会派发更多的任务给这个进程；相应地，任务处理慢的进程，其队列也会减少得慢，这样负载均衡器会派发更少的任务给这个进程。因此，通过这些任务队列，负载均衡器在派发任务时将进程处理任务的能力因素考虑了进去。</p>
<p><img src="http://img.blog.csdn.net/20161227233657531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图5：均匀任务队列派发策略</p>
<h1 id="单一队列（Autonomous-Queue-Scheme）"><a href="#单一队列（Autonomous-Queue-Scheme）" class="headerlink" title="单一队列（Autonomous Queue Scheme）"></a>单一队列（Autonomous Queue Scheme）</h1><p>与上面的均匀队列策略一样，单一队列策略也使用了队列来实现负载均衡。不同的是，单一队列策略只使用了一个队列。图6是单一队列策略的原理图。</p>
<p><img src="http://img.blog.csdn.net/20161227233744423?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图6：单一队列策略</p>
<p>单一队列策略中，实际上并没有负载均衡器的存在。所有的服务器进程从队列中取出任务执行，如果某个进程出现宕机的情况，那么其他进程仍然可以继续执行任务。这样一来，任务队列并不需要知道服务进程的情况，只需要服务进程知道自己的任务队列，并不断执行任务即可。<br>单一队列策略实际上也考虑到进程的处理能力，进程处理任务得越快，其从队列取出任务的速度也越快。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于负载均衡为系统提供了水平扩展的能力以及提高了系统的高可用性，因此，负载均衡在分布式系统中的作用可谓十分重要。在实际使用中，我们可以充分利用一些已有的负载均衡硬件或者软件为我们实现负载均衡。硬件方面有F5，A10，软件方面有Nginx，HAProxy，LVS等。即使是自己实现，也可以考虑现有的开源软件，比如任务队列可以使用RabbitMQ，等。与其重复造轮子，不如先站在巨人的肩膀上:)</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://tutorials.jenkov.com/software-architecture/load-balancing.html" target="_blank" rel="external">http://tutorials.jenkov.com/software-architecture/load-balancing.html</a></li>
<li><a href="http://www.oschina.net/news/77156/load-balance" target="_blank" rel="external">http://www.oschina.net/news/77156/load-balance</a></li>
<li><a href="http://nginx.org/en/docs/http/load_balancing.html" target="_blank" rel="external">http://nginx.org/en/docs/http/load_balancing.html</a></li>
<li>构建高性能Web站点，第十二章，郭欣著，2012年6月，第二版</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://leehao.io/2017/01/24/一致性Hash-Consistent-Hashing-原理剖析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="李生">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="李生的博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="李生的博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/24/一致性Hash-Consistent-Hashing-原理剖析/" itemprop="url">
                  一致性Hash(Consistent Hashing)原理剖析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-24T14:38:46+08:00">
                2017-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/24/一致性Hash-Consistent-Hashing-原理剖析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/24/一致性Hash-Consistent-Hashing-原理剖析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>在业务开发中，我们常把数据持久化到数据库中。如果需要读取这些数据，除了直接从数据库中读取外，为了减轻数据库的访问压力以及提高访问速度，我们更多地引入缓存来对数据进行存取。读取数据的过程一般为：</p>
<p><img src="http://img.blog.csdn.net/20170123084346849?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图1：加入缓存的数据读取过程</p>
<p>对于分布式缓存，不同机器上存储不同对象的数据。为了实现这些缓存机器的负载均衡，可以使用式子1来定位对象缓存的存储机器：</p>
<blockquote>
<p>m = hash(o) mod n    ——式子1</p>
</blockquote>
<p>其中，<code>o</code>为对象的名称，<code>n</code>为机器的数量，<code>m</code>为机器的编号，<code>hash</code>为一hash函数。图2中的负载均衡器（load balancer）正是使用式子1来将客户端对不同对象的请求分派到不同的机器上执行，例如，对于对象o，经过式子1的计算，得到<code>m</code>的值为3，那么所有对对象o的读取和存储的请求都被发往机器3执行。</p>
<p><img src="http://img.blog.csdn.net/20170108001037193?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图2：如何利用Hash取模实现负载均衡</p>
<p>式子1在大部分时候都可以工作得很好，然而，当机器需要扩容或者机器出现宕机的情况下，事情就比较棘手了。<br>当机器扩容，需要增加一台缓存机器时，负载均衡器使用的式子变成：</p>
<blockquote>
<p>m = hash(o) mod (n + 1)    ——式子2</p>
</blockquote>
<p>当机器宕机，机器数量减少一台时，负载均衡器使用的式子变成：</p>
<blockquote>
<p>m = hash(o) mod (n - 1)    ——式子3</p>
</blockquote>
<p>我们以机器扩容的情况为例，说明简单的取模方法会导致什么问题。假设机器由3台变成4台，对象o1由式子1计算得到的m值为2，由式子2计算得到的m值却可能为0，1，2，3（一个 3t + 2的整数对4取模，其值可能为0，1，2，3，读者可以自行验证），大约有75%（3/4)的可能性出现缓存访问不命中的现象。随着机器集群规模的扩大，这个比例线性上升。当99台机器再加入1台机器时，不命中的概率是99%（99/100）。这样的结果显然是不能接受的，因为这会导致数据库访问的压力陡增，严重情况，还可能导致数据库宕机。</p>
<p>一致性hash算法正是为了解决此类问题的方法，它可以保证当机器增加或者减少时，对缓存访问命中的概率影响减至很小。下面我们来详细说一下一致性hash算法的具体过程。</p>
<h1 id="一致性Hash环"><a href="#一致性Hash环" class="headerlink" title="一致性Hash环"></a>一致性Hash环</h1><p>一致性hash算法通过一个叫作一致性hash环的数据结构实现。这个环的起点是0，终点是2^32 - 1，并且起点与终点连接，环的中间的整数按逆时针分布，故这个环的整数分布范围是[0, 2^32-1]，如下图3所示：</p>
<p><img src="http://img.blog.csdn.net/20170108000506549?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图3：一致性Hash环</p>
<h1 id="将对象放置到Hash环"><a href="#将对象放置到Hash环" class="headerlink" title="将对象放置到Hash环"></a>将对象放置到Hash环</h1><p>假设现在我们有4个对象，分别为o1，o2，o3，o4，使用hash函数计算这4个对象的hash值（范围为0 ~ 2^32-1）:</p>
<blockquote>
<p>hash(o1) = m1<br>hash(o2) = m2<br>hash(o3) = m3<br>hash(o4) = m4</p>
</blockquote>
<p>把m1，m2，m3，m4这4个值放置到hash环上，得到如下图4：</p>
<p><img src="http://img.blog.csdn.net/20170108001141907?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图4：放置了对象的一致性Hash环</p>
<h1 id="将机器放置到Hash环"><a href="#将机器放置到Hash环" class="headerlink" title="将机器放置到Hash环"></a>将机器放置到Hash环</h1><p>使用同样的hash函数，我们将机器也放置到hash环上。假设我们有三台缓存机器，分别为 c1，c2，c3，使用hash函数计算这3台机器的hash值：</p>
<blockquote>
<p>hash(c1) = t1<br>hash(c2) = t2<br>hash(c3) = t3</p>
</blockquote>
<p>把t1，t2，t3 这3个值放置到hash环上，得到如下图5：</p>
<p><img src="http://img.blog.csdn.net/20170108001228002?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图5：放置了机器的一致性Hash环</p>
<h1 id="为对象选择机器"><a href="#为对象选择机器" class="headerlink" title="为对象选择机器"></a>为对象选择机器</h1><p>将对象和机器都放置到同一个hash环后，在hash环上顺时针查找距离这个对象的hash值最近的机器，即是这个对象所属的机器。<br>例如，对于对象o2，顺序针找到最近的机器是c1，故机器c1会缓存对象o2。而机器c2则缓存o3，o4，机器c3则缓存对象o1。</p>
<p><img src="http://img.blog.csdn.net/20170108001326379?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图6：在一致性Hash环上为对象选择机器</p>
<h1 id="处理机器增减的情况"><a href="#处理机器增减的情况" class="headerlink" title="处理机器增减的情况"></a>处理机器增减的情况</h1><p>对于线上的业务，增加或者减少一台机器的部署是常有的事情。<br>例如，增加机器c4的部署并将机器c4加入到hash环的机器c3与c2之间。这时，只有机器c3与c4之间的对象需要重新分配新的机器。对于我们的例子，只有对象o4被重新分配到了c4，其他对象仍在原有机器上。如图7所示：</p>
<p><img src="http://img.blog.csdn.net/20170108001504023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图7：增加机器后的一致性Hash环的结构</p>
<p>如上文前面所述，使用简单的求模方法，当新添加机器后会导致大部分缓存失效的情况，使用一致性hash算法后这种情况则会得到大大的改善。前面提到3台机器变成4台机器后，缓存命中率只有25%（不命中率75%）。而使用一致性hash算法，理想情况下缓存命中率则有75%，而且，随着机器规模的增加，命中率会进一步提高，99台机器增加一台后，命中率达到99%，这大大减轻了增加缓存机器带来的数据库访问的压力。</p>
<p>再例如，将机器c1下线（当然，也有可能是机器c1宕机），这时，只有原有被分配到机器c1对象需要被重新分配到新的机器。对于我们的例子，只有对象o2被重新分配到机器c3，其他对象仍在原有机器上。如图8所示：</p>
<p><img src="http://img.blog.csdn.net/20170108001520632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图8：减少机器后的一致性Hash环的结构</p>
<h1 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h1><p>上面提到的过程基本上就是一致性hash的基本原理了，不过还有一个小小的问题。新加入的机器c4只分担了机器c2的负载，机器c1与c3的负载并没有因为机器c4的加入而减少负载压力。如果4台机器的性能是一样的，那么这种结果并不是我们想要的。<br>为此，我们引入虚拟节点来解决负载不均衡的问题。<br>将每台物理机器虚拟为一组虚拟机器，将虚拟机器放置到hash环上，如果需要确定对象的机器，先确定对象的虚拟机器，再由虚拟机器确定物理机器。<br>说得有点复杂，其实过程也很简单。</p>
<p>还是使用上面的例子，假如开始时存在缓存机器c1，c2，c3，对于每个缓存机器，都有3个虚拟节点对应，其一致性hash环结构如图9所示：</p>
<p><img src="http://img.blog.csdn.net/20170108000617634?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图9：机器c1，c2，c3的一致性Hash环结构</p>
<p>假设对于对象o1，其对应的虚拟节点为c11，而虚拟节点c11对象缓存机器c1，故对象o1被分配到机器c1中。</p>
<p>新加入缓存机器c4，其对应的虚拟节点为c41，c42，c43，将这三个虚拟节点添加到hash环中，得到的hash环结构如图10所示：</p>
<p><img src="http://img.blog.csdn.net/20170108000625603?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>图10：机器c1，c2，c3，c4的一致性Hash环结构</p>
<p>新加入的缓存机器c4对应一组虚拟节点c41，c42，c43，加入到hash环后，影响的虚拟节点包括c31，c22，c11（顺时针查找到第一个节点），而这3个虚拟节点分别对应机器c3，c2，c1。即新加入的一台机器，同时影响到原有的3台机器。理想情况下，新加入的机器平等地分担了原有机器的负载，这正是虚拟节点带来的好处。而且新加入机器c4后，只影响25%（1/4）对象分配，也就是说，命中率仍然有75%，这跟没有使用虚拟节点的一致性hash算法得到的结果是相同的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一致性hash算法解决了分布式环境下机器增加或者减少时，简单的取模运算无法获取较高命中率的问题。通过虚拟节点的使用，一致性hash算法可以均匀分担机器的负载，使得这一算法更具现实的意义。正因如此，一致性hash算法被广泛应用于分布式系统中。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><p><a href="https://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="external">https://en.wikipedia.org/wiki/Consistent_hashing</a></p>
</li>
<li><p><a href="https://www.codeproject.com/articles/56138/consistent-hashing" target="_blank" rel="external">https://www.codeproject.com/articles/56138/consistent-hashing</a></p>
</li>
<li><p>《大型网站技术架构——核心原理与安全分析》，李智慧著，电子工业出版社</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="李生" />
          <p class="site-author-name" itemprop="name">李生</p>
          <p class="site-description motion-element" itemprop="description">分布式，架构，C++，Python</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李生</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"leehao"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  

  

  

  

  


</body>
</html>
